---
title: 'Syntethic Missing Data Generation Study '
output:
  html_document:
    df_print: paged
---


```{r}
set.seed(1)
n <- 100
```

# Missing Values generation

The **mechanisms for generating missing data** can be classified into different types based on how the data is missing in relation to the observed and unobserved values. 

Here is a summary focusing on **Missing Completely at Random (MCAR)** and **Conditionally at Random (CAR, often referred to as MAR – Missing At Random)** mechanisms:

## Missing Completely at Random (MCAR)

**Definition**: In the MCAR mechanism, the missingness is entirely independent of both observed and unobserved data. The probability that data is missing does not depend on any feature values.
$$P(M | X, \xi) = P(M | \xi)$$

**Implementation**: Missing values are inserted randomly across the dataset, either using Bernoulli trials or random selection methods. Common configurations include univariate (one feature) or multivariate (multiple features) generation, with random positions selected for deletion.

MCAR mechanisms are straightforward since missingness is independent of any feature values. Various methods can be used to generate MCAR data:

**Univariate MCAR Implementation**: Only one feature in the dataset has missing values. *Methods*:

  - **Random Position Selection**: Select a feature $x_{miss}$ and delete values at random positions using a random number generator or permutation.  
  - **Bernoulli Trials**: Use Bernoulli trials to determine missingness. A success probability $p$ corresponds to the desired missing rate (MR). Each data point has a probability $p$ of being set as missing.  
    Example: For a missing rate of 10% in a feature with 100 observations, 10 random positions are marked as missing.
    
**Challenges**:  

  - For small datasets, Bernoulli trials may lead to variation in the actual missing rate due to random variation from small sample sizes.

**Multivariate MCAR Implementation**: Missing values are distributed across multiple features. *Methods*:

  - **Uniform Distribution**: Generate missing values equally across all features. Each feature has the same missing rate.  
  - **Random Distribution**: Choose a total number of missing values based on the desired MR and randomly select cells across the dataset.  
    Example: For a dataset with 1,000 values and a 20% missing rate, 200 cells are randomly selected for deletion across all features.  

**Strengths**: Simple and easy to implement; assumptions are often met in real-world data due to purely random events.  
**Limitations**: The randomness does not reflect dependencies often present in real-world missingness patterns.

## Missing At Random (MAR or CAR)

**Definition**: In the CAR (MAR) mechanism, the probability of missing data depends on the values of observed data but not on the unobserved (missing) values themselves. It assumes a dependency between missingness and observed features.

$$P(M | X, \xi) = P(M | X_{obs}, \xi)$$

**Example**: Younger participants in a smoking survey might be more likely to skip reporting their cigarette consumption, but the missingness is independent of the actual number of cigarettes consumed.

**Implementation**: Several approaches exist, often involving a determining feature. For instance, missing values in one feature (like cigarette consumption) may depend on values of another observed feature (like age). Configurations can involve ranks, percentiles, or division into groups based on a feature’s value.

Each mechanism carries implications for analysis and imputation, as assumptions about the data's structure influence how accurately the missing values can be predicted or imputed.

In MAR mechanisms, missingness depends on observed values of other features but not on the missing values themselves. This adds complexity to the generation process:

**Univariate MAR Implementation**: Missing values in one feature $x_{miss}$ are determined by the values of another feature $x_{obs}$ (also called the determining feature). *Methods*:

  - **Rank-Based Selection**: Compute the ranks of $x_{obs}$ and assign higher or lower probabilities for missingness based on these ranks.  
    Example: Select a feature $x_{age}$. Younger participants (lower ranks) may have a higher probability of missingness in a related feature $x_{smoking\_habits}$.  
    - Probability of missingness for each pattern:  
      $P(x_{i,miss} = \text{missing}) = \frac{r_{i,obs}}{\sum r_{i,obs}}$  
      where $r_{i,obs}$ is the rank of the $i^{th}$ observation of $x_{obs}$.  
  - **Percentile or Cut-off Method**: Sort the values of $x_{obs}$ and choose missing positions in $x_{miss}$ corresponding to lower values in $x_{obs}$. The cutoff may be determined by a percentile.  
    Example: Missing values in $x_{income}$ might be set for individuals below the 25th percentile of $x_{education\_level}$.  

**Multivariate MAR Implementation**: MAR for multiple features requires defining relationships among multiple pairs of features. *Methods*:
  
  - **Pairs of Features**:  
    Select pairs $\{x_{obs}, x_{miss}\}$ for each combination of features. Missing values in $x_{miss}$ are inserted based on observed values in $x_{obs}$.  
    Example: Create missing values in $x_{cholesterol}$ based on high or low values of $x_{age}$. Adjust missing rates for individual features to maintain the overall dataset’s MR.  

  - **Correlated Feature Sets**:  
    When the dataset contains correlated features, missingness can be simulated in dependent features. MAR implementations often simulate this by ordering features by correlation or mutual information with the class label and generating missing values progressively.

**Challenges**:  

- MAR implementations can be sensitive to the choice of the determining feature. Consistent experimental design is crucial when evaluating imputation methods using synthetic MAR data.  
- Generating accurate MAR patterns requires careful tuning of dependency relationships, especially when working with nominal or categorical features, as ranking or ordering becomes problematic.

In R, the missMethods library allows efficient generation of missing values under different mechanisms (MCAR, MAR, MNAR), aiding in testing imputation methods and evaluating missing data impacts.

```{r}
library(missMethods)
library(VIM)
```



```{r}
# Generate covariates
x1 <- rnorm(n)
x2 <- rnorm(n)
x3 <- rnorm(n)
x4 <- rnorm(n)
x5 <- rnorm(n)
x6 <- rnorm(n)

# Define coefficients

intercept <- 0
beta <-c(1, 1, 1, 1, 1, 1)

# Error term
epsilon <- rnorm(n)

# Generate response for Linear model
y <- intercept +  
  (beta[1] * x1) + (beta[2] * x2) + (beta[3] * x3) + 
  (beta[4] * x4) + (beta[5] * x5) + (beta[6] * x6) +
  epsilon

# Create a data frame with reduced variables
data <- data.frame(y, x1, x2, x3, x4, x5, x6)
```

```{r}
summary(lm(y~., data = data))
```

```{r}
data.MCAR.uni <- delete_MCAR(data, p = 0.1, cols_mis = c('x1'), n_mis_stochastic = F)
aggr(data.MCAR.uni, numbers=TRUE, sortVars=TRUE, labels=names(data))
```

```{r}
data.MCAR.multi <- delete_MCAR(data, p = 0.1, cols_mis = c('x1','x2','x3'), n_mis_stochastic = F)
aggr(data.MCAR.multi, numbers=TRUE, labels=names(data), prop = c(TRUE, FALSE))
```
The `delete_MAR_censoring()` function in R creates Missing At Random (MAR) values by censoring data in one column (`cols_mis`) based on values in another column (`cols_ctrl`). It divides the data into groups using either sorting or quantiles. Missing values are created:

- where = "lower": in rows with the smallest values in cols_ctrl.
- where = "upper": in rows with the largest values.
- where = "both": in both extremes, splitting missingness between the smallest and largest values.

The p parameter determines the proportion of missing values, and sorting controls whether to use sorting or quantiles for determining cutoffs.

```{r}
data.MAR.uni <- delete_MAR_censoring(data,p = 0.1, cols_mis = c('x1'), cols_ctrl = c('x2'))
aggr(data.MAR.uni, numbers=TRUE, labels=names(data), prop = c(TRUE, FALSE))
plot(data$x1,data$x2, col = 'red')
points(data.MAR.uni$x1,data.MAR.uni$x2)
```

The `delete_MAR_1_to_x()` function in R creates **Missing At Random (MAR)** values by controlling missingness in one column (`cols_mis`) based on the values of another column (`cols_ctrl`). It splits the data into two groups using a cutoff value (e.g., median) in `cols_ctrl`. Group 1 contains rows below the cutoff, and group 2 contains rows above. The `x` parameter sets the odds ratio of missing data: for `x = 3`, group 2 is **3 times** more likely to have missing values than group 1.

```{r}
data.MAR.multi <- delete_MAR_1_to_x(data,p = 0.1, cols_mis = c('x1','x2'), cols_ctrl = c('x3','x4'), x = 10)
```
```{r}
aggr(data.MAR.multi, numbers=TRUE, labels=names(data), prop = c(TRUE, FALSE))
```

```{r}
plot(data$x1,data$x3, col = 'red')
points(data.MAR.multi$x1,data.MAR.multi$x3)

plot(data$x2,data$x4, col = 'red')
points(data.MAR.multi$x2,data.MAR.multi$x4)

```





